import { optimize } from 'svgo';

function getSVGOPlugins(options) {
  return [
    "cleanupAttrs",
    "mergeStyles",
    "inlineStyles",
    "removeComments",
    "removeUselessDefs",
    "removeEditorsNSData",
    "removeEmptyAttrs",
    "removeEmptyContainers",
    "convertStyleToAttrs",
    "convertColors",
    "convertTransform",
    "removeUnknownsAndDefaults",
    "removeNonInheritableGroupAttrs",
    "removeUnusedNS",
    "cleanupNumericValues",
    "cleanupListOfValues",
    "moveElemsAttrsToGroup",
    "moveGroupAttrsToElems",
    "collapseGroups",
    "sortDefsChildren",
    "sortAttrs",
    ...options.animated ? [] : ["removeUselessStrokeAndFill"],
    ...options.animated || options.keepShapes ? [] : [
      "removeHiddenElems",
      "convertShapeToPath",
      "convertEllipseToCircle",
      {
        name: "convertPathData",
        params: {
          noSpaceAfterFlags: true
        }
      },
      {
        name: "mergePaths",
        params: {
          noSpaceAfterFlags: true
        }
      },
      "reusePaths"
    ],
    ...options.cleanupIDs !== false ? [
      {
        name: "cleanupIDs",
        params: {
          prefix: typeof options.cleanupIDs === "string" ? options.cleanupIDs : "svgID"
        }
      }
    ] : []
  ];
}
function runSVGO(svg, options = {}) {
  const code = svg.toString();
  const multipass = options.multipass !== false;
  let plugins;
  if (options.plugins) {
    plugins = options.plugins;
  } else {
    const animated = code.indexOf("<animate") !== -1 || code.indexOf("<set") !== -1;
    plugins = getSVGOPlugins({
      ...options,
      animated
    });
  }
  const pluginOptions = {
    plugins,
    multipass
  };
  const result = optimize(code, pluginOptions);
  if (typeof result.error === "string") {
    throw new Error(result.error);
  }
  const content = result.data.replace(/<defs\/>/g, "");
  svg.load(content);
}

export { getSVGOPlugins, runSVGO };
